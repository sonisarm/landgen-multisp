---
title: "Create raster input"
description: R code to create raster inputs for ResistanceGA
output: Rasters for resistance surface modeling in .asc format
---


Load libraries
```{r setup, include=FALSE, message=FALSE}
library(terra)
library(sp)
library(raster)
library(dplyr)
library(tidyr)
library(tidyverse)
library(readxl) 
```



# Load rasters

Load environmental rasters (climate + topography + wind). 

The environmental predictor raster is a multi-layer SpatRaster containing all surfaces you want to evaluate in ResistanceGA (e.g., BIO variables, slope, curvature, wind). If your predictors are separate files, you can load them individually and combine them later with c() or rast(list_of_files).

If you are running island-specific analyses, this example assumes one predictor raster per island.

```{r raster}
isl <- 'LP'
raster <- rast(paste0("Spatraster", isl, ".tif"))

```


Build an ENM stack (one layer per species)

ENM predictions are species-specific. This code loops through species folders inside a folder named "SDM", loads the present scenario ensemble raster, normalizes each raster independently to 0â€“1, aligns grids across species, and stacks them into a single multi-layer SpatRaster.

```{r enm}

folders  <- c('species1', 'species2', 'species3')

base_dir <- "../SDM"

# container for layers
r_list <- vector("list", length(folders))
names(r_list) <- folders

# normalize each raster independently
normalize <- function(r) {
  rmin <- terra::global(r, "min", na.rm = TRUE)[1, 1]
  rmax <- terra::global(r, "max", na.rm = TRUE)[1, 1]
  if (is.na(rmin) || is.na(rmax) || rmax == rmin) return(r * NA)  # avoid /0
  (r - rmin) / (rmax - rmin)
}

template <- NULL

for (sp in folders) {

  r <- rast(file.path(
    base_dir, sp, scenario[1],
    paste0(scenario[1], "_", sp, "_ensemble.tif")
  ))

  r <- normalize(r)
  r <- crop(r, vect)

  # force identical grid across layers (recommended)
  if (is.null(template)) {
    template <- r
  } else {
    r <- resample(r, template, method = "near")
  }

  names(r) <- paste0("p_", sp, "_", isl)
  r_list[[sp]] <- r
}

# build the stack (multi-layer SpatRaster)
assign(paste0("enm_", isl), rast(r_list))

```


# Option 1: Crop predictors and ENM to island extent

If your rasters are larger than the island (e.g., archipelago-wide), crop them to the island polygon. 
Additional (not shown): Use mask() if you want values outside the polygon to be set to NA.

```{r crop to island limits}
# climate / topography / wind data
vect <- vect(paste0(isl, ".shp"))
raster <- crop(raster, vect)

# enm data
enm <- get(paste0("enm_", isl))
enm <- crop(enm, vect)

```



# Option 2: Crop to buffer size around coordinates

This workflow creates a single analysis extent that covers all sampling locations (across all populations/species) and then crops all predictor layers (eg. temperature, precipitation, topography, wind) and the ENM stack to that same extent. This ensures every downstream analysis uses rasters with identical spatial coverage.

1) Load and filter coordinates

Read the full coordinate table, coerce X/Y to numeric, remove excluded records, and retain only samples from the focal island. The resulting coordinate set represents all sites used to define the shared analysis extent.
```{r load coordinates}

Coord <- read_excel("coords.xlsx", sheet = "All") 
Coord$X <- as.numeric(as.character(Coord$X)) # make sure your coordinates are numeric
Coord$Y <- as.numeric(as.character(Coord$Y))

```

2) Create a buffer around all sampling points

Convert the filtered coordinates into a SpatVector with the same CRS as the predictor rasters (merged). Then create a buffer (e.g., 3 km) around each point and dissolve all buffers into a single polygon (buf_union). This polygon defines the common spatial footprint used to crop all rasters.
```{r create buffer}
pts <- vect(Coord, geom = c("X", "Y"), crs = crs(merged))
buf_dist <- 3000  # e.g., 3km
buf <- terra::buffer(pts, buf_dist)   # positional argument
# optional: dissolve all buffers into a single polygon
buf_union <- aggregate(buf)

```


3) Crop rasters to the buffered NP extent

Crop each raster (or raster layer) to the shared buffer polygon. This produces a consistent set of inputs (same spatial extent) across layers of interest for the multi-species analyses. The ENM stack is loaded based on the island code (isl) and cropped to the same extent.
```{r}

# example: temperature
b1 <- crop(merged$bio_01, buf_union)
# ENM (multi-layer SpatRaster; one layer per species)
enm <- get(paste0("enm_", isl))
enm <- crop(enm, buf_union)
```


# Export ResistanceGA inputs (ASCII grid)

Export either a single predictor layer (e.g., bio_01) or multiple layers. ResistanceGA typically expects one ASCII grid per surface.

```{r save resistanceGA raster input}
# for example, save bio-01 and enm:
b1 <- raster$bio_01
writeRaster(b1, "bio01.asc", filetype = "AAIGrid", overwrite=TRUE)
writeRaster(enm, "enm_species1.asc", filetype = "AAIGrid", overwrite=TRUE)

# Repeat for other variables of interest
```

